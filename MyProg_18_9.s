; Технология поблочного копирования данных
; Объявить кодовую секцию MyCode
				AREA MyCode, CODE, ReadOnly
; Объявить точку входа в программу приложения	
				ENTRY
; Объвить точку входа глобальной переменной
				EXPORT MyProg
MyProg
; Основная программа
; Число элементов исходного массива слов
N				EQU		20
; 			...
; Передать параметры и вызвать подпрограмму 
; поблочного копирования данных 
				LDR r0,=Array_SRC		; Адрес массива - источника
				LDR r1,=Array_DST		; Адрес массива - приемника
				MOV r2,#N						; Число слов в массиве
				BL Copy_Array_Block
; Повторить для другого набора данных в исходном массиве
				B MyProg

;****************************************************************
; Подпрограмма копирования массива слов с использованием 
; команд множественной загрузки/сохранения регистров процессора 
; Входы:
; Параметры, передаваемые в подпрограмму содержимым регистров:
; r0 – указатель на начальный адрес массива-источника
; r1 – указатель на начальный адрес массива-приемника
; r2 – число слов массива-источника, подлежащих копированию
; Используемые регистры:
; r3 – счетчик числа блоковых пересылок и регистр временного 
;      хранения слова при обычном копировании
; r4-r11 – банк из 8-и регистров ЦПУ для временного приема данных
;****************************************************************
Copy_Array_Block 
; Сохранить в стеке содержимое используемого регистра r3
			PUSH {r3}
; Определить число блоков слов (по 8 слов) в массиве и сохранить в r3
; То есть проинициализировать счетчик числа блочных операций
; Логический попутный сдвиг на 3 разряда вправо (деление на 2*2*2=8)
			MOVS r3,r2,LSR #3 	; «S» - сформировать флаги результата
; Если число блочных операций равно 0, то скопировать оставшиеся слова
			BEQ Copy_Rest
			
Block_Copy
; Выполняем блочное копирование большей части элементов исходного массива
; Сохранить текущее содержимое регистров (r4-r11), используемых в
; в качестве 8-и словного «аккумулятора» в системном стеке (декрементном)
			PUSH {r4-r11}				; или STMDB sp!, {r4-r11} 	 

; По блочное копирование с использованием восьми регистров процессора
; (r4-r11) в качестве временного «аккумулятора»
Copy_Oct 
; Загрузка 8-регистров данными из массива-источника с авто-смещением
; содержимого регистра указателя r0 на +4 при каждой операции чтения
; (c инкрементированием указателя r0 после доступа IA)
			LDMIA r0!, {r4-r11} 
; Сохранение полученного блока из 8 слов в массиве-приемнике
; с авто-смещением содержимого регистра указателя r1 при каждой 
; операции записи на +4  (тоже с инкрементированием после доступа)
			STMIA r1!, {r4-r11}
; Декрементировать счетчик числа блоковых пересылок
			SUBS r3,#1 	; «S» - установить флаги результата
; Если не все блоковые операции выполнены - продолжить
			BNE Copy_Oct 

; Восстановить контекст из стека, т.к. регистровый блочный
; «аккумулятор» (r4-r11) больше не потребуется	
			POP {r4-r11}				; или LDMIA sp!, {r4-r11} 

; По словное копирование оставшихся элементов массива
Copy_Rest
; Выделим младшие три бита в числе слов, подлежащих копированию
; По сути: получим остаток от деления этого числа на 8
			ANDS r2,#7 	; «S» - выработать флаги результата
; Если остаток нулевой – все слова скопированы
			BEQ End_Sub 
; Обычное по-словное копирование
; Оба указателя r0 и r1 проинициализированы за счет операции
; авто-обновления «!» при множественной загрузке/сохранении регистров	
Copy_Word 
			LDR r3,[r0],#4 	; Копировать из массива-источника
			STR r3,[r1],#4 	; Сохранить в массиве-приемнике
			SUBS r2,#1 	; Декрементировать счетчик числа циклов
			BNE Copy_Word	; Повторить при необходимости
; Все элементы скопированы.
End_Sub
; Восстановить из стека содержимое регистра r3
			POP {r3}
; Возврат в основную программу
			BX lr						; или MOV pc,lr
;********************************************************************

; Объявить секцию данных в оперативной памяти и зарезервировать место
; для массива- источника и массива-приемника данных
					ALIGN				; Выровнять по границе полного слова
					AREA MyData, DATA, ReadWrite
Array_SRC	SPACE N*4
Array_DST SPACE N*4
	
; Конец ассемблерного текста
				END